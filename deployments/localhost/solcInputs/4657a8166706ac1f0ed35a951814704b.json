{
  "language": "Solidity",
  "sources": {
    "contracts/storage/AppStorageInit.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./LibAppStorage.sol\";\n\ncontract AppStorageInit {\n    /// @notice Initializes the app with default state values\n    /// @dev Add any AppStorage struct properties here to initialize values\n    function init(IERC20 sarcoToken, uint256 protocolFee) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Add the ERC20 token to app storage (Sarco)\n        s.sarcoToken = sarcoToken;\n        s.protocolFee = protocolFee;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/storage/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\n\n// Global storage for the app. Can be accessed in facets and in libraries\nstruct AppStorage {\n    IERC20 sarcoToken;\n    // The amount to be taken from the embalmer each time a protocol fee should\n    // be collected\n    uint256 protocolFee;\n    // The amount of protocol fees currently stored on the contract\n    uint256 totalProtocolFees;\n    // sarcophagi\n    bytes32[] sarcophagusIdentifiers;\n    // Each archaeologist's total free and cursed bonds\n    mapping(address => uint256) freeBonds;\n    mapping(address => uint256) cursedBonds;\n    // archaeologist stats\n    mapping(address => mapping(bytes32 => bool)) archaeologistSuccesses;\n    mapping(address => bytes32[]) archaeologistCancels;\n    mapping(address => bytes32[]) archaeologistAccusals;\n    mapping(address => bytes32[]) archaeologistCleanups;\n    // Track how much archaeologists have made. To be credited and debited\n    // as archaeologists fulfil their duties and withdraw their rewards\n    mapping(address => uint256) archaeologistRewards;\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\n    // sarcophagus ownerships\n    mapping(address => bytes32[]) embalmerSarcophagi;\n    mapping(address => bytes32[]) archaeologistSarcophagi;\n    mapping(address => bytes32[]) recipientSarcophagi;\n    // Mapping of unencrypted shard double hashes to archaeologists who are\n    // responsible for them. Needed to optimise Accuse algo - unencrypted shard is\n    // double hashed and used as a constant O(1) lookup here\n    mapping(bytes32 => address) doubleHashedShardArchaeologists;\n    // A mapping used to store an archaeologist's data on a sarcophagus.\n    // Bounty, digging fees, storage fees, and the hashed shards of the\n    // archaeologists all need to be stored per sarcophagus. This mapping of a\n    // mapping stores the archaeologist's data we need per sarcophagus.\n    // Example usage (to retrieve the bounty an archaeologist may claim on some sarcophagus):\n    //   LibTypes.ArchaeologistStorage bondedArchaeologist = sarcophagusArchaeologists[sarcoId][archAddress];\n    //   uint256 bounty = bondedArchaeologist.bounty;\n    mapping(bytes32 => mapping(address => LibTypes.ArchaeologistStorage)) sarcophagusArchaeologists;\n}\n\nlibrary LibAppStorage {\n    function getAppStorage() internal pure returns (AppStorage storage s) {\n        // Set the position of our struct in contract storage\n        // Since AppStorage s is the first and only state variable declared in\n        // facets its position in contract storage is 0\n        assembly {\n            s.slot := 0\n        }\n    }\n}\n"
    },
    "contracts/libraries/LibTypes.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title A collection of defined structs\n * @notice This library defines the various data models that the Sarcophagus\n * system uses\n */\nlibrary LibTypes {\n    // DoesNotExist must come first on the list to be the default value\n    enum SarcophagusState {\n        DoesNotExist,\n        Exists,\n        Done\n    }\n\n    // A struct of just the signature. This is used primarily by the\n    // finalizeSarcpohagus function for the arweave archaeologist. Note that,\n    // unlike the regular archaeologists, the sarcophagus already stores the\n    // single arweave archaeologist's address so there is no need to pass in the\n    // address to the finalizeSarcophagus function.\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // Signature struct created to make passing in the signature argmuments into\n    // finalizedSarcophagus easier and to avoid the \"stack too deep\" error.\n    // Also attaching arachaeologist addresses so we can tie the signature back\n    // to the address in finalizeSarcophagus.\n    struct SignatureWithAccount {\n        address account;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // ArchaeologistMemory is the struct that is passed into the\n    // initializeSarcophagus function. Even though we don't need each storage\n    // fee of the archaeologist, the storage fee is included in the struct to\n    // reduce the stack size within the function, preventing the \"stack too\n    // deep\" error.\n    struct ArchaeologistMemory {\n        address archAddress;\n        uint256 storageFee;\n        uint256 diggingFee;\n        uint256 bounty;\n        bytes32 hashedShard;\n    }\n\n    // ArchaeologistStorage is the struct that is stored in AppStorage under the\n    // sarcophagusArchaeologists mapping.\n    //\n    // The archaeologist address is left out since each archaeologist's address\n    // is stored on the sarcophagus object as an array.\n    //\n    // The storage fee is left out becuase we only need to store the storage fee\n    // of the archaeologist uploading to arweave, which will be stored directly\n    // on the sarcophagus.\n    struct ArchaeologistStorage {\n        uint256 diggingFee;\n        uint256 bounty;\n        bytes32 doubleHashedShard;\n        bytes unencryptedShard;\n    }\n\n    // The ArchaeologistStorage struct could be contained in this Sarcophagus\n    // struct as a mapping, but it was put into it's own mapping\n    // (sarcophagusArchaeologists) directly in AppStorage. Instead the\n    // sarcophagus stores the addresses of each archaeologist added to it. This\n    // was done to simplify the creation of a sarcophagus object in\n    // initializeSarcophagus.\n    struct Sarcophagus {\n        string name;\n        SarcophagusState state;\n        bool canBeTransferred;\n        uint8 minShards;\n        uint256 resurrectionTime;\n        uint256 maxResurrectionInterval;\n        string[] arweaveTxIds;\n        uint256 storageFee;\n        address embalmer;\n        address recipientAddress;\n        address arweaveArchaeologist;\n        address[] archaeologists;\n    }\n}\n"
    },
    "contracts/facets/ViewStateFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../libraries/LibTypes.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract ViewStateFacet {\n    AppStorage internal s;\n\n    /// @notice Gets the total protocol fees from the contract.\n    /// @return The total protocol fees\n    function getTotalProtocolFees() external view returns (uint256) {\n        return s.totalProtocolFees;\n    }\n\n    /// @notice Get the protocol fee amount from the contract.\n    /// @return The protocol fee amount\n    function getProtocolFeeAmount() external view returns (uint256) {\n        return s.protocolFee;\n    }\n\n    /// @notice Returns the amount of free bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being returned\n    function getFreeBond(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.freeBonds[archaeologist];\n    }\n\n    /// @notice Returns the amount of rewards stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// reward is being returned\n    function getAvailableRewards(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.archaeologistRewards[archaeologist];\n    }\n\n    /// @notice Returns the amount of cursed bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being returned\n    function getCursedBond(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.cursedBonds[archaeologist];\n    }\n\n    function getArchaeologistSuccessOnSarcophagus(\n        address archaeologist,\n        bytes32 sarcoId\n    ) external view returns (bool) {\n        return s.archaeologistSuccesses[archaeologist][sarcoId];\n    }\n\n    /// @notice Returns the number of accusations for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose accusations\n    /// are being returned\n    function getArchaeologistAccusals(address archaeologist)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.archaeologistAccusals[archaeologist];\n    }\n\n    /// @notice Returns the number of cleanups for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose cleanups\n    /// are being returned\n    function getArchaeologistCleanups(address archaeologist)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.archaeologistCleanups[archaeologist];\n    }\n\n    /// @notice Returns a sarcophagus.\n    /// @param sarcoId The identifier of the sarcophagus being returned\n    function getSarcophagus(bytes32 sarcoId)\n        external\n        view\n        returns (LibTypes.Sarcophagus memory)\n    {\n        return s.sarcophagi[sarcoId];\n    }\n\n    /// @notice Given an embalmer's address, returns the identifiers of all\n    /// sarcophagi that the embalmer has created.\n    /// @param embalmer The address of the embalmer whose sarcophagi are being\n    /// returned\n    function getEmbalmersarcophagi(address embalmer)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.embalmerSarcophagi[embalmer];\n    }\n\n    /// @notice Given an archaeologist's address, returns the identifiers of all\n    /// sarcophagi that the archaeologist has participated in.\n    /// @param archaeologist The address of the archaeologist whose sarcophagi\n    /// are being returned\n    function getArchaeologistsarcophagi(address archaeologist)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.archaeologistSarcophagi[archaeologist];\n    }\n\n    /// @notice Given a recipient's address, returns the identifiers of all\n    /// sarcophagi that the recipient has participated in.\n    /// @param recipient The address of the recipient whose sarcophagi are being\n    /// returned\n    function getRecipientsarcophagi(address recipient)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.recipientSarcophagi[recipient];\n    }\n\n    /// @notice Returns the data stored on a sarcophagus for an archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus whose data is being\n    /// returned\n    /// @param archaeologist The address of the archaeologist whose data is\n    /// being returned\n    function getSarcophagusArchaeologist(bytes32 sarcoId, address archaeologist)\n        external\n        view\n        returns (LibTypes.ArchaeologistStorage memory)\n    {\n        return s.sarcophagusArchaeologists[sarcoId][archaeologist];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}