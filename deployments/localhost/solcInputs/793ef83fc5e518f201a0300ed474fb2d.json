{
  "language": "Solidity",
  "sources": {
    "contracts/facets/AdminFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract AdminFacet {\n    AppStorage internal s;\n\n    /// @notice Withdraws the total protocol fee amount from the contract.\n    /// @dev Can only be called by the owner.\n    function withdrawProtocolFees() external {\n        // TODO: confirm that sender is owner\n\n        // Get the total protocol fees from storage\n        uint256 totalProtocolFees = s.totalProtocolFees;\n\n        // Set the total protocol fees to 0 before the transfer to avoid reentrancy\n        s.totalProtocolFees = 0;\n\n        // Transfer the protocol fee amount to the sender after setting state\n        s.sarcoToken.transfer(msg.sender, totalProtocolFees);\n    }\n}\n"
    },
    "contracts/storage/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\n\n// Global storage for the app. Can be accessed in facets and in libraries\nstruct AppStorage {\n    IERC20 sarcoToken;\n    // The amount to be taken from the embalmer each time a protocol fee should\n    // be collected\n    uint256 protocolFee;\n    // The amount of protocol fees currently stored on the contract\n    uint256 totalProtocolFees;\n    // sarcophagi\n    bytes32[] sarcophagusIdentifiers;\n    // Each archaeologist's total free and cursed bonds\n    mapping(address => uint256) freeBonds;\n    mapping(address => uint256) cursedBonds;\n    // archaeologist stats\n    mapping(address => mapping(bytes32 => bool)) archaeologistSuccesses;\n    mapping(address => bytes32[]) archaeologistCancels;\n    mapping(address => bytes32[]) archaeologistAccusals;\n    mapping(address => bytes32[]) archaeologistCleanups;\n    // Track how much archaeologists have made. To be credited and debited\n    // as archaeologists fulfil their duties and withdraw their rewards\n    mapping(address => uint256) archaeologistRewards;\n    mapping(bytes32 => LibTypes.Sarcophagus) sarcophagi;\n    // sarcophagus ownerships\n    mapping(address => bytes32[]) embalmerSarcophagi;\n    mapping(address => bytes32[]) archaeologistSarcophagi;\n    mapping(address => bytes32[]) recipientSarcophagi;\n    // Mapping of unencrypted shard double hashes to archaeologists who are\n    // responsible for them. Needed to optimise Accuse algo - unencrypted shard is\n    // double hashed and used as a constant O(1) lookup here\n    mapping(bytes32 => address) doubleHashedShardArchaeologists;\n    // A mapping used to store an archaeologist's data on a sarcophagus.\n    // Bounty, digging fees, storage fees, and the hashed shards of the\n    // archaeologists all need to be stored per sarcophagus. This mapping of a\n    // mapping stores the archaeologist's data we need per sarcophagus.\n    // Example usage (to retrieve the bounty an archaeologist may claim on some sarcophagus):\n    //   LibTypes.ArchaeologistStorage bondedArchaeologist = sarcophagusArchaeologists[sarcoId][archAddress];\n    //   uint256 bounty = bondedArchaeologist.bounty;\n    mapping(bytes32 => mapping(address => LibTypes.ArchaeologistStorage)) sarcophagusArchaeologists;\n}\n\nlibrary LibAppStorage {\n    function getAppStorage() internal pure returns (AppStorage storage s) {\n        // Set the position of our struct in contract storage\n        // Since AppStorage s is the first and only state variable declared in\n        // facets its position in contract storage is 0\n        assembly {\n            s.slot := 0\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/libraries/LibTypes.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title A collection of defined structs\n * @notice This library defines the various data models that the Sarcophagus\n * system uses\n */\nlibrary LibTypes {\n    // DoesNotExist must come first on the list to be the default value\n    enum SarcophagusState {\n        DoesNotExist,\n        Exists,\n        Done\n    }\n\n    // A struct of just the signature. This is used primarily by the\n    // finalizeSarcpohagus function for the arweave archaeologist. Note that,\n    // unlike the regular archaeologists, the sarcophagus already stores the\n    // single arweave archaeologist's address so there is no need to pass in the\n    // address to the finalizeSarcophagus function.\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // Signature struct created to make passing in the signature argmuments into\n    // finalizedSarcophagus easier and to avoid the \"stack too deep\" error.\n    // Also attaching arachaeologist addresses so we can tie the signature back\n    // to the address in finalizeSarcophagus.\n    struct SignatureWithAccount {\n        address account;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    // ArchaeologistMemory is the struct that is passed into the\n    // initializeSarcophagus function. Even though we don't need each storage\n    // fee of the archaeologist, the storage fee is included in the struct to\n    // reduce the stack size within the function, preventing the \"stack too\n    // deep\" error.\n    struct ArchaeologistMemory {\n        address archAddress;\n        uint256 storageFee;\n        uint256 diggingFee;\n        uint256 bounty;\n        bytes32 hashedShard;\n    }\n\n    // ArchaeologistStorage is the struct that is stored in AppStorage under the\n    // sarcophagusArchaeologists mapping.\n    //\n    // The archaeologist address is left out since each archaeologist's address\n    // is stored on the sarcophagus object as an array.\n    //\n    // The storage fee is left out becuase we only need to store the storage fee\n    // of the archaeologist uploading to arweave, which will be stored directly\n    // on the sarcophagus.\n    struct ArchaeologistStorage {\n        uint256 diggingFee;\n        uint256 bounty;\n        bytes32 doubleHashedShard;\n        bytes unencryptedShard;\n    }\n\n    // The ArchaeologistStorage struct could be contained in this Sarcophagus\n    // struct as a mapping, but it was put into it's own mapping\n    // (sarcophagusArchaeologists) directly in AppStorage. Instead the\n    // sarcophagus stores the addresses of each archaeologist added to it. This\n    // was done to simplify the creation of a sarcophagus object in\n    // initializeSarcophagus.\n    struct Sarcophagus {\n        string name;\n        SarcophagusState state;\n        bool canBeTransferred;\n        uint8 minShards;\n        uint256 resurrectionTime;\n        uint256 maxResurrectionInterval;\n        string[] arweaveTxIds;\n        uint256 storageFee;\n        address embalmer;\n        address recipientAddress;\n        address arweaveArchaeologist;\n        address[] archaeologists;\n    }\n}\n"
    },
    "contracts/storage/AppStorageInit.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./LibAppStorage.sol\";\n\ncontract AppStorageInit {\n    /// @notice Initializes the app with default state values\n    /// @dev Add any AppStorage struct properties here to initialize values\n    function init(IERC20 sarcoToken, uint256 protocolFee) external {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Add the ERC20 token to app storage (Sarco)\n        s.sarcoToken = sarcoToken;\n        s.protocolFee = protocolFee;\n    }\n}\n"
    },
    "contracts/facets/ThirdPartyFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract ThirdPartyFacet {\n    AppStorage internal s;\n\n    event AccuseArchaeologist(\n        bytes32 indexed sarcoId,\n        address indexed accuser,\n        uint256 accuserBondReward,\n        uint256 embalmerBondReward\n    );\n\n    event CleanUpSarcophagus(\n        bytes32 indexed sarcoId,\n        address indexed cleaner,\n        uint256 cleanerBondReward,\n        uint256 embalmerBondReward\n    );\n\n    /// @notice Close a sarcophagus that has not been unwrapped before its resurrection window is passed\n    /// @param sarcoId The identifier of the sarcophagus to clean\n    /// @param paymentAddress The address to which rewards will be sent\n    function clean(bytes32 sarcoId, address paymentAddress) external {\n        LibTypes.Sarcophagus storage sarco = s.sarcophagi[sarcoId];\n\n        if (sarco.state != LibTypes.SarcophagusState.Exists) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Make sure the sarco is cleanable\n        if (\n            block.timestamp <\n            LibUtils.getGracePeriod(sarco.resurrectionTime) +\n                sarco.resurrectionTime\n        ) {\n            revert LibErrors.SarcophagusNotCleanable();\n        }\n\n        // Figure out which archaeoligists did not fulfil their duties;\n        // accumulate their digging fees and bounties\n        address[] memory archAddresses = sarco.archaeologists;\n\n        uint256 totalCursedBond;\n        uint256 totalDiggingFee;\n        uint256 totalBounty;\n\n        for (uint256 i = 0; i < archAddresses.length; i++) {\n            bool didNotUnwrap = s.archaeologistSuccesses[archAddresses[i]][\n                sarcoId\n            ] == false;\n\n            if (didNotUnwrap) {\n                LibTypes.ArchaeologistStorage memory defaulter = s\n                    .sarcophagusArchaeologists[sarcoId][archAddresses[i]];\n\n                totalBounty += defaulter.bounty;\n                totalDiggingFee += defaulter.diggingFee;\n\n                uint256 cursedBond = LibBonds.calculateCursedBond(\n                    defaulter.diggingFee,\n                    defaulter.bounty\n                );\n\n                totalCursedBond += cursedBond;\n\n                // decrease the defaulter's cursed bond\n                LibBonds.decreaseCursedBond(archAddresses[i], cursedBond);\n\n                // Save the failure to unwrap against the archaeologist\n                s.archaeologistCleanups[archAddresses[i]].push(sarcoId);\n            }\n        }\n\n        (\n            uint256 cleanerBondReward,\n            uint256 embalmerBondReward\n        ) = _distributeLoot(\n                paymentAddress,\n                sarco,\n                totalCursedBond,\n                totalDiggingFee,\n                totalBounty\n            );\n\n        sarco.state = LibTypes.SarcophagusState.Done;\n\n        emit CleanUpSarcophagus(\n            sarcoId,\n            msg.sender,\n            cleanerBondReward,\n            embalmerBondReward\n        );\n    }\n\n    /**\n     * @notice Accuse archaeologoists of bad behaviour, by providing proof of leaked\n     * unencrypted shards before a sarcophagus is ready to be unwrapped. The minumum\n     * number of shards required to unwrap the sarcophagus should be provided for a\n     * a successful accusal.\n     * of the cursed bonds of the archs back to them, and un-curses their bonds.\n     * @param sarcoId The identifier of the sarcophagus having leaked shards\n     * @param unencryptedShardHashes At least 'm' unencrypted shard hashes as proof of bad behaviour\n     * @param paymentAddress the address to which rewards should be sent if successful\n     */\n    function accuse(\n        bytes32 sarcoId,\n        bytes32[] memory unencryptedShardHashes,\n        address paymentAddress\n    ) external {\n        LibTypes.Sarcophagus storage sarco = s.sarcophagi[sarcoId];\n\n        if (sarco.state != LibTypes.SarcophagusState.Exists) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        if (sarco.resurrectionTime < block.timestamp) {\n            revert LibErrors.SarcophagusIsUnwrappable();\n        }\n\n        if (unencryptedShardHashes.length < sarco.minShards) {\n            revert LibErrors.NotEnoughProof();\n        }\n\n        address[] memory accusedArchAddresses = new address[](\n            unencryptedShardHashes.length\n        );\n\n        // For each provided shard hash, check if its hash matches one on storage. If so, flag that\n        // archaeologist as accusable\n        uint256 diggingFeesToBeDistributed = 0;\n        uint256 bountyToBeDistributed = 0;\n        uint256 totalCursedBond = 0;\n        uint256 pos = 0;\n        for (uint256 i = 0; i < unencryptedShardHashes.length; i++) {\n            bytes32 shardDoubleHash = keccak256(\n                abi.encode(unencryptedShardHashes[i])\n            );\n\n            address matchingArchAddr = s.doubleHashedShardArchaeologists[\n                shardDoubleHash\n            ];\n\n            LibTypes.ArchaeologistStorage storage badArch = s\n                .sarcophagusArchaeologists[sarcoId][matchingArchAddr];\n\n            if (badArch.doubleHashedShard == shardDoubleHash) {\n                accusedArchAddresses[pos++] = matchingArchAddr;\n\n                uint256 cursedBond = LibBonds.calculateCursedBond(\n                    badArch.diggingFee,\n                    badArch.bounty\n                );\n\n                diggingFeesToBeDistributed += badArch.diggingFee;\n                bountyToBeDistributed += badArch.bounty;\n                totalCursedBond += cursedBond;\n\n                LibBonds.decreaseCursedBond(matchingArchAddr, cursedBond);\n\n                // Save the accusal against the archaeologist\n                s.archaeologistAccusals[matchingArchAddr].push(sarcoId);\n            } else {\n                revert LibErrors.NotEnoughProof();\n            }\n        }\n\n        // At this point, we need to filter out unaccused archs in order to reimburse them.\n        address[] memory bondedArchaeologists = s\n            .sarcophagi[sarcoId]\n            .archaeologists;\n\n        for (uint256 i = 0; i < bondedArchaeologists.length; i++) {\n            // Need to check each archaeologist address on the sarcophagus\n            bool isUnaccused = true;\n\n            for (uint256 j = 0; j < accusedArchAddresses.length; j++) {\n                // For each arch address, if found in accusedArchAddresses,\n                // then don't add to unaccusedArchsAddresses\n                if (bondedArchaeologists[i] == accusedArchAddresses[j]) {\n                    isUnaccused = false;\n                    break;\n                }\n            }\n\n            // If this arch address wasn't in the accused list, free it from its curse\n            if (isUnaccused) {\n                // There are technically no rewards here, since the sarcophagus\n                // has been compromised, so here this effectively merely resets\n                // the state of the non-malicious archaeologists, as if they never\n                // bonded to this sarcophagus in the first place.\n                //\n                // Of course, whatever rewards they might have gained in previous\n                // rewraps remains theirs.\n                LibBonds.freeArchaeologist(sarcoId, bondedArchaeologists[i]);\n            }\n        }\n\n        (\n            uint256 accuserBondReward,\n            uint256 embalmerBondReward\n        ) = _distributeLoot(\n                paymentAddress,\n                sarco,\n                totalCursedBond,\n                diggingFeesToBeDistributed,\n                bountyToBeDistributed\n            );\n\n        sarco.state = LibTypes.SarcophagusState.Done;\n\n        emit AccuseArchaeologist(\n            sarcoId,\n            msg.sender,\n            accuserBondReward,\n            embalmerBondReward\n        );\n    }\n\n    /**\n     * @notice Takes a sarcophagus's cursed bond, splits it in half, and sends\n     * to paymentAddress and embalmer\n     * @param paymentAddress payment address for the transaction caller\n     * @param sarc the sarcophagus to operate on\n     * @param totalCursedBond the sum of cursed bonds of all archs that failed to fulfil their duties\n     * @param totalDiggingFee the sum of digging fees of all archs that failed to fulfil their duties\n     * @param totalBounty the sum of bounties that would have been paid to all archs that failed to fulfil their duties\n     * @return halfToSender the amount of SARCO token going to transaction\n     * sender\n     * @return halfToEmbalmer the amount of SARCO token going to embalmer\n     */\n    function _distributeLoot(\n        address paymentAddress,\n        LibTypes.Sarcophagus storage sarc,\n        uint256 totalCursedBond,\n        uint256 totalDiggingFee,\n        uint256 totalBounty\n    ) private returns (uint256, uint256) {\n        // split the sarcophagus's cursed bond into two halves\n        uint256 halfToEmbalmer = totalCursedBond / 2;\n        uint256 halfToSender = totalCursedBond - halfToEmbalmer;\n\n        // transfer the cursed half, plus bounty, plus digging fee to the\n        // embalmer\n        s.sarcoToken.transfer(\n            sarc.embalmer,\n            totalBounty + totalDiggingFee + halfToEmbalmer\n        );\n\n        // transfer the other half of the cursed bond to the transaction caller\n        s.sarcoToken.transfer(paymentAddress, halfToSender);\n\n        return (halfToSender, halfToEmbalmer);\n    }\n\n    function _hashHelper(bytes memory data) private pure returns (bytes32) {\n        return keccak256(data);\n    }\n}\n"
    },
    "contracts/libraries/LibErrors.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\n/**\n * @title A collection of Errors\n * @notice This library defines all of the Errors that the Sarcophagus system\n * uses.\n */\nlibrary LibErrors {\n    error ArchaeologistAlreadyUnwrapped(address archaeologist);\n\n    error ArchaeologistListNotUnique(address[] archaeologists);\n\n    error ArchaeologistNotOnSarcophagus(address archaeologist);\n\n    error ArweaveArchaeologistNotInList();\n\n    error ArweaveTxIdEmpty();\n\n    error IncorrectNumberOfArchaeologistSignatures(uint256 signaturesLength);\n\n    error MinShardsGreaterThanArchaeologists(uint8 minShards);\n\n    error MinShardsZero();\n\n    error MaxResurrectionIntervalIsZero();\n\n    error NewResurrectionTimeInPast(uint256 newResurrectionTime);\n\n    error NewResurrectionTimeTooLarge(uint256 newResurrectionTime);\n\n    error NoArchaeologistsProvided();\n\n    error NotEnoughCursedBond(uint256 cursedBond, uint256 amount);\n\n    error NotEnoughFreeBond(uint256 freeBond, uint256 amount);\n\n    error NotEnoughReward(uint256 reward, uint256 amount);\n\n    error ResurrectionTimeInPast(uint256 resurrectionTime);\n\n    error SarcophagusAlreadyExists(bytes32 sarcoId);\n\n    error SarcophagusAlreadyFinalized(bytes32 sarcoId);\n\n    error SarcophagusNotFinalized(bytes32 sarcoId);\n\n    error SarcophagusDoesNotExist(bytes32 sarcoId);\n\n    error SenderNotEmbalmer(address sender, address embalmer);\n\n    error SignatureFromWrongAccount(\n        address hopefulAddress,\n        address actualAddress\n    );\n\n    error SignatureListNotUnique();\n\n    error SignerNotArchaeologistOnSarcophagus(bytes32 sarcoId, address signer);\n\n    // Used when an attempt is made to accuse or rewrap after the resurrection time has already passed (so it's actually time to unwrap it)\n    error SarcophagusIsUnwrappable();\n\n    // Used when an attempt is made to clean a sarcophagus that has not exceeded its resurrection window\n    error SarcophagusNotCleanable();\n\n    // Used when accusing with not enough, or invalid, unencrypted shard(s)\n    error NotEnoughProof();\n\n    error TooEarlyToUnwrap(uint256 resurrectionTime, uint256 currentTime);\n\n    error TooLateToUnwrap(\n        uint256 resurrectionTime,\n        uint256 resurrectionWindow,\n        uint256 currentTime\n    );\n\n    error UnencryptedShardHashMismatch(\n        bytes unencryptedShard,\n        bytes32 doubleHashedShard\n    );\n}\n"
    },
    "contracts/libraries/LibBonds.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\nlibrary LibBonds {\n    /// @notice Calculates the cursed bond that an archaeologist needs to lock\n    /// up\n    /// @dev The cursed bond amount is the sum of the digging fee and the\n    /// bounty.\n    /// @param diggingFee The digging fee of the sarcophagus\n    /// @param bounty The bounty of the sarcophagus\n    /// @return The amount of cursed bond\n    function calculateCursedBond(uint256 diggingFee, uint256 bounty)\n        internal\n        pure\n        returns (uint256)\n    {\n        // TODO: Implement a better algorithm for calculating the cursed bond\n        return diggingFee + bounty;\n    }\n\n    /// @notice Decreases the amount stored in the freeBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's free bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function decreaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current free bond\n        if (amount > s.freeBonds[archaeologist]) {\n            revert LibErrors.NotEnoughFreeBond(\n                s.freeBonds[archaeologist],\n                amount\n            );\n        }\n\n        // Decrease the free bond amount\n        s.freeBonds[archaeologist] -= amount;\n    }\n\n    /// @notice Increases the amount stored in the freeBond mapping for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being decreased\n    /// @param amount The amount to decrease the free bond by\n    function increaseFreeBond(address archaeologist, uint256 amount) internal {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Increase the free bond amount\n        s.freeBonds[archaeologist] += amount;\n    }\n\n    /// @notice Decreases the amount stored in the cursedBond mapping for an\n    /// archaeologist. Reverts if the archaeologist's cursed bond is lower than\n    /// the amount.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being decreased\n    /// @param amount The amount to decrease the cursed bond by\n    function decreaseCursedBond(address archaeologist, uint256 amount)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current cursed bond\n        if (amount > s.cursedBonds[archaeologist]) {\n            revert LibErrors.NotEnoughCursedBond(\n                s.cursedBonds[archaeologist],\n                amount\n            );\n        }\n\n        // Decrease the cursed bond amount\n        s.cursedBonds[archaeologist] -= amount;\n    }\n\n    /// @notice Increases the amount stored in the cursedBond mapping for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being decreased\n    /// @param amount The amount to decrease the cursed bond by\n    function increaseCursedBond(address archaeologist, uint256 amount)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Increase the cursed bond amount\n        s.cursedBonds[archaeologist] += amount;\n    }\n\n    /// @notice Locks up the archaeologist's bond, decreasing the\n    /// archaeologist's free bond by an amount and increasing the\n    /// archaeologist's cursed bond by the same amount.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to lock up\n    function lockUpBond(address archaeologist, uint256 amount) internal {\n        // Decrease the free bond amount\n        decreaseFreeBond(archaeologist, amount);\n\n        // Increase the cursed bond amount\n        increaseCursedBond(archaeologist, amount);\n    }\n\n    /// @notice Unlocks the archaeologist's bond, increasing the\n    /// archaeologist's free bond by an amount and decreasing the\n    /// archaeologist's cursed bond by the same amount.\n    /// @param archaeologist The address of the archaeologist\n    /// @param amount The amount to unlock\n    function unlockBond(address archaeologist, uint256 amount) internal {\n        // Decrease the cursed bond amount\n        decreaseCursedBond(archaeologist, amount);\n\n        // Increase the free bond amount\n        increaseFreeBond(archaeologist, amount);\n    }\n\n    /// @notice Given an array of archaeologists on a sarcophagus, sums the total of\n    /// 1. Each archaeologists' bounty\n    /// 2. Each archaeologists' digging fees\n    /// 3. The storage fee\n    /// @param sarcoId The identifier of the sarcophagus\n    /// @param archaeologists The array of archaeologists' addresses\n    /// @return the total of the above\n    function calculateTotalFees(\n        bytes32 sarcoId,\n        address[] memory archaeologists\n    ) internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        uint256 totalFees = 0;\n\n        // iterate through each archaeologist\n        for (uint256 i = 0; i < archaeologists.length; i++) {\n            LibTypes.ArchaeologistStorage memory archaeologistsData = s\n                .sarcophagusArchaeologists[sarcoId][archaeologists[i]];\n\n            // add the archaeologist's bounty to the total fees\n            totalFees += archaeologistsData.bounty;\n\n            // add the archaeologist's digging fee to the total fees\n            totalFees += archaeologistsData.diggingFee;\n        }\n\n        // add the storage fee to the total fees\n        totalFees += s.sarcophagi[sarcoId].storageFee;\n\n        // return the total fees\n        return totalFees;\n    }\n\n    /// @notice Calculates an archaeologist's cursed bond and curses them (locks\n    /// up the free bond).\n    /// @param sarcoId the identifier of the sarcophagus to bond the archaeologist with\n    /// @param archaeologist the address of the archaeologist to curse\n    function curseArchaeologist(bytes32 sarcoId, address archaeologist)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Get the archaeologist's data from storage\n        LibTypes.ArchaeologistStorage memory archaeologistData = s\n            .sarcophagusArchaeologists[sarcoId][archaeologist];\n\n        // Calculate the amount of cursed bond the archaeologists needs to lock up\n        uint256 cursedBondAmount = calculateCursedBond(\n            archaeologistData.diggingFee,\n            archaeologistData.bounty\n        );\n\n        // Lock up the archaeologist's bond by the cursed bond amount\n        lockUpBond(archaeologist, cursedBondAmount);\n    }\n\n    /// @notice Calculates an archaeologist's cursed bond and frees them\n    /// (unlocks the cursed bond).\n    /// @param sarcoId the identifier of the sarcophagus to free the archaologist from\n    /// @param archaeologist the address of the archaeologist to free\n    function freeArchaeologist(bytes32 sarcoId, address archaeologist)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Get the archaeologist's data from storage\n        LibTypes.ArchaeologistStorage memory archaeologistData = s\n            .sarcophagusArchaeologists[sarcoId][archaeologist];\n\n        // Calculate the amount of cursed bond the archaeologists needs to lock up\n        uint256 cursedBondAmount = calculateCursedBond(\n            archaeologistData.diggingFee,\n            archaeologistData.bounty\n        );\n\n        // Lock up the archaeologist's bond by the cursed bond amount\n        unlockBond(archaeologist, cursedBondAmount);\n    }\n}\n"
    },
    "contracts/libraries/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\n/**\n * @title Utility functions used within the Sarcophagus system\n * @notice This library implements various functions that are used throughout\n * Sarcophagus, mainly to DRY up the codebase\n * @dev these functions are all stateless, public, pure/view\n */\nlibrary LibUtils {\n    /**\n     * @notice Reverts if the public key length is not exactly 64 bytes long\n     * @param publicKey the key to check length of\n     */\n    function publicKeyLength(bytes memory publicKey) public pure {\n        require(publicKey.length == 64, \"public key must be 64 bytes\");\n    }\n\n    /**\n     * @notice Reverts if the hash of singleHash does not equal doubleHash\n     * @param doubleHash the hash to compare hash of singleHash to\n     * @param singleHash the value to hash and compare against doubleHash\n     */\n    function hashCheck(bytes32 doubleHash, bytes memory singleHash)\n        public\n        pure\n    {\n        require(doubleHash == keccak256(singleHash), \"hashes do not match\");\n    }\n\n    /**\n     * @notice Reverts if the input string is not empty\n     * @param assetId the string to check\n     */\n    function confirmAssetIdNotSet(string memory assetId) public pure {\n        require(bytes(assetId).length == 0, \"assetId has already been set\");\n    }\n\n    /**\n     * @notice Reverts if existing assetId is not empty, or if new assetId is\n     * @param existingAssetId the orignal assetId to check, make sure is empty\n     * @param newAssetId the new assetId, which must not be empty\n     */\n    function assetIdsCheck(\n        string memory existingAssetId,\n        string memory newAssetId\n    ) public pure {\n        // verify that the existingAssetId is currently empty\n        confirmAssetIdNotSet(existingAssetId);\n\n        require(bytes(newAssetId).length > 0, \"assetId must not have 0 length\");\n    }\n\n    function archaeologistUnwrappedCheck(bytes32 sarcoId, address archaeologist)\n        internal\n        view\n    {\n        if (\n            getArchaeologist(sarcoId, archaeologist).unencryptedShard.length > 0\n        ) {\n            revert LibErrors.ArchaeologistAlreadyUnwrapped(archaeologist);\n        }\n    }\n\n    /**\n     * @notice Given some bytes32 data, a signature, and an account, verify that the\n     * identifier was signed by the account.\n     * @dev The verifyBytes32Signature function is identical to the\n     * verifyBytesSignature function except for the data type being passed in.\n     * The reason these are split up is beacuse it's really tricky to convert a\n     * bytes32 value into a bytes value and have ecrecover still work properly.\n     * If a simple solution can be found for this problem then please combine\n     * these two functions together.\n     * @param data the data to verify\n     * @param v signature element\n     * @param r signature element\n     * @param s signature element\n     * @param account address to confirm data and signature came from\n     */\n    function verifyBytes32Signature(\n        bytes32 data,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address account\n    ) internal pure {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encode(data))\n            )\n        );\n\n        // Genearate the address from the signature.\n        // ecrecover should always return a valid address.\n        address hopefulAddress = ecrecover(messageHash, v, r, s);\n\n        if (hopefulAddress != account) {\n            revert LibErrors.SignatureFromWrongAccount(hopefulAddress, account);\n        }\n    }\n\n    /**\n     * @notice Given an identifier, a signature, and an account, verify that the\n     * identifier was signed by the account.\n     * @dev The verifyBytes32Signature function is identical to the\n     * verifyBytesSignature function except for the data type being passed in.\n     * The reason these are split up is beacuse it's really tricky to convert a\n     * bytes32 value into a bytes value and have ecrecover still work properly.\n     * If a simple solution can be found for this problem then please combine\n     * these two functions together.\n     * @param data the data to verify\n     * @param v signature element\n     * @param r signature element\n     * @param s signature element\n     * @param account address to confirm data and signature came from\n     */\n    function verifyBytesSignature(\n        bytes memory data,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address account\n    ) internal pure {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encode(data))\n            )\n        );\n\n        // Genearate the address from the signature.\n        // ecrecover should always return a valid address.\n        // It's highly recommended that a hash be passed into ecrecover\n        address hopefulAddress = ecrecover(messageHash, v, r, s);\n\n        if (hopefulAddress != account) {\n            revert LibErrors.SignatureFromWrongAccount(hopefulAddress, account);\n        }\n    }\n\n    /// @notice Returns the address that signed some data given the data and the\n    /// signature.\n    /// @param data the data to verify\n    /// @param v signature element\n    /// @param r signature element\n    /// @param s signature element\n    /// @return the address that signed the data\n    function recoverAddress(\n        bytes memory data,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // Hash the hash of the data payload\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encode(data))\n            )\n        );\n\n        // Genearate the address from the signature.\n        // ecrecover should always return a valid address.\n        // It's highly recommended that a hash be passed into ecrecover\n        address account = ecrecover(messageHash, v, r, s);\n\n        return account;\n    }\n\n    /**\n     * @notice Reverts if the given resurrection time is not in the future\n     * @param resurrectionTime the time to check against block.timestamp\n     */\n    function resurrectionInFuture(uint256 resurrectionTime) internal view {\n        if (resurrectionTime <= block.timestamp) {\n            revert LibErrors.ResurrectionTimeInPast(resurrectionTime);\n        }\n    }\n\n    /**\n     * @notice Calculates the grace period that an archaeologist has after a\n     * sarcophagus has reached its resurrection time\n     * @param resurrectionTime the resurrection timestamp of a sarcophagus\n     * @return the grace period\n     * @dev The grace period is dependent on how far out the resurrection time\n     * is. The longer out the resurrection time, the longer the grace period.\n     * There is a minimum grace period of 30 minutes, otherwise, it's\n     * calculated as 1% of the time between now and resurrection time.\n     */\n    function getGracePeriod(uint256 resurrectionTime)\n        internal\n        view\n        returns (uint256)\n    {\n        // set a minimum window of 30 minutes\n        uint16 minimumResurrectionWindow = 30 minutes;\n\n        // calculate 1% of the relative time between now and the resurrection\n        // time\n        uint256 gracePeriod = (\n            resurrectionTime > block.timestamp\n                ? resurrectionTime - block.timestamp\n                : block.timestamp - resurrectionTime\n        ) / 100;\n\n        // if our calculated grace period is less than the minimum time, we'll\n        // use the minimum time instead\n        if (gracePeriod < minimumResurrectionWindow) {\n            gracePeriod = minimumResurrectionWindow;\n        }\n\n        // return that grace period\n        return gracePeriod;\n    }\n\n    /**\n     * @notice Reverts if we're not within the resurrection window (on either\n     * side)\n     * @param resurrectionTime the resurrection time of the sarcophagus\n     * (absolute, i.e. a date time stamp)\n     */\n    function unwrapTime(uint256 resurrectionTime) internal view {\n        // revert if too early\n        if (resurrectionTime > block.timestamp) {\n            revert LibErrors.TooEarlyToUnwrap(\n                resurrectionTime,\n                block.timestamp\n            );\n        }\n\n        uint256 resurrectionWindow = getGracePeriod(resurrectionTime);\n\n        // revert if too late\n        if (resurrectionTime + resurrectionWindow < block.timestamp) {\n            revert LibErrors.TooLateToUnwrap(\n                resurrectionTime,\n                resurrectionWindow,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @notice Checks if the archaeologist exists on the sarcophagus.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param archaeologist the address of the archaeologist\n    /// @return The boolean true if the archaeologist exists on the sarcophagus\n    function archaeologistExistsOnSarc(bytes32 sarcoId, address archaeologist)\n        internal\n        view\n        returns (bool)\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // If the doubleHashedShard on an archaeologist is 0 (which is its default value),\n        // then the archaeologist doesn't exist on the sarcophagus\n        return\n            s\n            .sarcophagusArchaeologists[sarcoId][archaeologist]\n                .doubleHashedShard != 0;\n    }\n\n    /// @notice Gets an archaeologist given the sarcophagus identifier and the\n    /// archaeologist's address.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param archaeologist the address of the archaeologist\n    /// @return The archaeologist\n    function getArchaeologist(bytes32 sarcoId, address archaeologist)\n        internal\n        view\n        returns (LibTypes.ArchaeologistStorage memory)\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        return s.sarcophagusArchaeologists[sarcoId][archaeologist];\n    }\n\n    /// @notice Checks if a sarcophagus has been finalized by checking if it\n    /// contains any arweaveTxIds.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @return The boolean true if the sarcophagus has been finalized\n    function isSarcophagusFinalized(bytes32 sarcoId)\n        internal\n        view\n        returns (bool)\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        return s.sarcophagi[sarcoId].arweaveTxIds.length > 0;\n    }\n\n    /// @notice Calculates the protocol fees to be taken from the embalmer.\n    /// @return The protocol fees amount\n    function calculateProtocolFee() internal view returns (uint256) {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // TODO: Need feedback from the community to determine how protocol fees should be calculated\n        // Just returns a constant value defined in an env file\n        return s.protocolFee;\n    }\n}\n"
    },
    "contracts/facets/EmbalmerFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibRewards} from \"../libraries/LibRewards.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract EmbalmerFacet {\n    // IMPORTANT: AppStorage must be the first state variable in the facet.\n    AppStorage internal s;\n\n    event InitializeSarcophagus(\n        bytes32 indexed sarcoId,\n        address embalmer,\n        uint256 totalFees\n    );\n\n    event FinalizeSarcophagus(bytes32 indexed sarcoId, string arweaveTxId);\n\n    event RewrapSarcophagus(bytes32 indexed sarcoId, uint256 resurrectionTime);\n\n    event CancelSarcophagus(bytes32 indexed sarcoId);\n\n    event BurySarcophagus(bytes32 indexed sarcoId);\n\n    // Archaeologist's addresses are added to this mapping per sarcophagus to\n    // verify that the same archaeologist signature is not used more than once.\n    mapping(bytes32 => mapping(address => bool)) private verifiedArchaeologists;\n\n    /// @notice Embalmer creates the skeleton for a new sarcopahgus.\n    ///\n    /// InitializeSarcophagus is the first step of the two step mummification\n    /// process.\n    ///\n    /// The purpose of intializeSarcophagus is to:\n    ///   - Lock up payment for the archaeologists (bounty, digging fees, and storage fee)\n    ///   - Store hashes of the unencrypted shards on chain\n    ///   - Store the particapting archaeologists' addresses and individual\n    ///     denominations of fees dedicated to each\n    ///   - Create the sarcophagus object\n    ///\n    /// After initializeSarcophagus the archaeologists have been chosen but may\n    /// have no knowledge of the sarcophagus yet. An archaeologist still needs\n    /// to upload a payload to arweave and also communicate directly with the\n    /// embalmer to indicate that they are ready to do work. After this the\n    /// finalizeSarcohpagus() method should be called, which is the second step.\n    ///\n    /// @param name the name of the sarcophagus\n    /// @param archaeologists the data for the archaeologists\n    /// @param arweaveArchaeologist The address of the archaeologist who uploads to arweave\n    /// @param recipient the address of the recipient\n    /// @param resurrectionTime the resurrection time of the sarcophagus\n    /// @param maxResurrectionInterval the maximum length of time that any new resurrection times can be from time of rewrap\n    /// @dev archaeologists will have to sign off on this interval, and commit to it for the lifetime of the sarcophagus.\n    /// @param canBeTransferred Whether the sarcophagus can be transferred\n    /// @param minShards The minimum number of shards required to unwrap the sarcophagus\n    /// @return The index of the new sarcophagus\n    function initializeSarcophagus(\n        string memory name,\n        LibTypes.ArchaeologistMemory[] memory archaeologists,\n        address arweaveArchaeologist,\n        address recipient,\n        uint256 resurrectionTime,\n        uint256 maxResurrectionInterval,\n        bool canBeTransferred,\n        uint8 minShards\n    ) external returns (uint256) {\n        bytes32 sarcoId = keccak256(abi.encodePacked(name));\n\n        // Confirm that this exact sarcophagus does not already exist\n        if (\n            s.sarcophagi[sarcoId].state !=\n            LibTypes.SarcophagusState.DoesNotExist\n        ) {\n            revert LibErrors.SarcophagusAlreadyExists(sarcoId);\n        }\n\n        // Confirm that the ressurection time is in the future\n        if (resurrectionTime <= block.timestamp) {\n            revert LibErrors.ResurrectionTimeInPast(resurrectionTime);\n        }\n\n        // Confirm that archaeologists are provided\n        if (archaeologists.length == 0) {\n            revert LibErrors.NoArchaeologistsProvided();\n        }\n\n        // Confirm that minShards is less than the number of archaeologists\n        if (minShards > archaeologists.length) {\n            revert LibErrors.MinShardsGreaterThanArchaeologists(minShards);\n        }\n\n        // Confirm that minShards is greater than 0\n        if (minShards == 0) {\n            revert LibErrors.MinShardsZero();\n        }\n\n        // Confirm that maxResurrectionInterval is greater than 0\n        if (maxResurrectionInterval == 0) {\n            revert LibErrors.MaxResurrectionIntervalIsZero();\n        }\n\n        // Initialize a list of archaeologist addresses to be passed in to the\n        // sarcophagus object\n        address[] memory archaeologistsToBond = new address[](\n            archaeologists.length\n        );\n\n        // Initialize the storage fee of the archaeologist who uploades to\n        // arweave. This will be obtained in the for loop and stored on the\n        // sarcophagus object.\n        uint256 storageFee = 0;\n\n        for (uint256 i = 0; i < archaeologists.length; i++) {\n            LibTypes.ArchaeologistMemory memory arch = archaeologists[i];\n\n            // Confirm that the archaeologist list is unique. This is done by\n            // checking that the archaeologist does not already exist from\n            // previous iterations in this loop.\n            if (LibUtils.archaeologistExistsOnSarc(sarcoId, arch.archAddress)) {\n                revert LibErrors.ArchaeologistListNotUnique(\n                    archaeologistsToBond\n                );\n            }\n\n            // If the archaeologist is the arweave archaeologist, set the\n            // storage fee. This is the only storage fee we care about.\n            if (arch.archAddress == arweaveArchaeologist) {\n                storageFee = arch.storageFee;\n            }\n\n            // Define an archaeologist storage object to be stored on the sarcophagus.\n            bytes32 doubleHashedShard = keccak256(abi.encode(arch.hashedShard));\n            LibTypes.ArchaeologistStorage memory archaeologistStorage = LibTypes\n                .ArchaeologistStorage({\n                    diggingFee: arch.diggingFee,\n                    bounty: arch.bounty,\n                    doubleHashedShard: doubleHashedShard,\n                    unencryptedShard: \"\"\n                });\n\n            // Map the double-hashed shared to this archaeologist's address for easier referencing on accuse\n            s.doubleHashedShardArchaeologists[doubleHashedShard] = arch\n                .archAddress;\n\n            // Stores each archaeologist's bounty, digging fees, and unencrypted\n            // shard in app storage per sarcophagus\n            s.sarcophagusArchaeologists[sarcoId][\n                arch.archAddress\n            ] = archaeologistStorage;\n\n            // Add the sarcophagus identifier to archaeologist's list of sarcophagi\n            s.archaeologistSarcophagi[arch.archAddress].push(sarcoId);\n\n            // Add the archaeologist address to the list of addresses to be\n            // passed in to the sarcophagus object\n            archaeologistsToBond[i] = arch.archAddress;\n        }\n\n        // If the storage fee is 0, then the storage fee was never set since the\n        // default value is 0. This means that either the arweave archaeologist\n        // was not included in the list of archaeologists or the arweave\n        // archaeologist set their storage fee to 0. In either case the\n        // transaction should be reverted.\n        if (storageFee == 0) {\n            revert LibErrors.ArweaveArchaeologistNotInList();\n        }\n\n        // Create the sarcophagus object and store it in AppStorage\n        s.sarcophagi[sarcoId] = LibTypes.Sarcophagus({\n            name: name,\n            state: LibTypes.SarcophagusState.Exists,\n            canBeTransferred: canBeTransferred,\n            minShards: minShards,\n            resurrectionTime: resurrectionTime,\n            maxResurrectionInterval: maxResurrectionInterval,\n            arweaveTxIds: new string[](0),\n            storageFee: storageFee,\n            embalmer: msg.sender,\n            recipientAddress: recipient,\n            arweaveArchaeologist: arweaveArchaeologist,\n            archaeologists: archaeologistsToBond\n        });\n\n        // Add the identifier to the necessary data structures\n        s.sarcophagusIdentifiers.push(sarcoId);\n        s.embalmerSarcophagi[msg.sender].push(sarcoId);\n        s.recipientSarcophagi[recipient].push(sarcoId);\n\n        // Calculate the total fees in sarco tokens that the contract will\n        // receive from the embalmer\n        uint256 totalFees = LibBonds.calculateTotalFees(\n            sarcoId,\n            archaeologistsToBond\n        );\n\n        // Transfer the total fees amount in sarco token from the msg.sender to this contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), totalFees);\n\n        // Emit the event\n        emit InitializeSarcophagus(sarcoId, msg.sender, totalFees);\n\n        // Return the index of the sarcophagus\n        return s.sarcophagusIdentifiers.length - 1;\n    }\n\n    /// @notice Embalmer finalizes the skeleton of a sarcophagus.\n    ///\n    /// FinalizeSarcophagus is the last step of the two step mummification\n    /// process.\n    ///\n    /// The purpose of finalizeSarcophagus is to:\n    ///   - Provide the archaeologists' signatures to the contract. These\n    ///     confirm that the archaeologists approve the fees stored on the\n    ///     contract and are ready to work.\n    ///   - Provide the arweave transaction id to be stored on chain.\n    ///   - Reward the archaeologist who uploaded to payload to arweave with the storage fee.\n    ///\n    /// @dev The archaeologistSignatures must be sent in the same order that the\n    /// archaeologists were sent to the initializeSarcophagus function,\n    /// otherwise the transaction will revert.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param archaeologistSignatures the signatures of the archaeologists.\n    /// This is archaeologist.length - 1 since the arweave archaeologist will be providing their own signature.\n    /// @param arweaveArchaeologistSignature the signature of the archaeologist who uploaded to arweave\n    /// @param arweaveTxId the arweave transaction id\n    function finalizeSarcophagus(\n        bytes32 sarcoId,\n        LibTypes.SignatureWithAccount[] memory archaeologistSignatures,\n        LibTypes.Signature memory arweaveArchaeologistSignature,\n        string memory arweaveTxId\n    ) external {\n        // Confirm that the sarcophagus exists\n        if (s.sarcophagi[sarcoId].state != LibTypes.SarcophagusState.Exists) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm that the embalmer is making this transaction\n        if (s.sarcophagi[sarcoId].embalmer != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(\n                msg.sender,\n                s.sarcophagi[sarcoId].embalmer\n            );\n        }\n\n        // Confirm that the sarcophagus is not already finalized by checking if\n        // the arweaveTxId is empty\n        if (LibUtils.isSarcophagusFinalized(sarcoId)) {\n            revert LibErrors.SarcophagusAlreadyFinalized(sarcoId);\n        }\n\n        // Confirm that the provided arweave transaction id is not empty\n        if (bytes(arweaveTxId).length == 0) {\n            revert LibErrors.ArweaveTxIdEmpty();\n        }\n\n        // Confirm that the correct number of archaeologist signatures was sent\n        // This will be archaeologist.length - 1 since the arweave archaeoligist\n        // will be providing their own signature.\n        if (\n            archaeologistSignatures.length !=\n            s.sarcophagi[sarcoId].archaeologists.length - 1\n        ) {\n            revert LibErrors.IncorrectNumberOfArchaeologistSignatures(\n                archaeologistSignatures.length\n            );\n        }\n\n        // Iterate over each regular archaeologist signature. This will not\n        // include the arweave archaeologist.\n        for (uint256 i = 0; i < archaeologistSignatures.length; i++) {\n            // Confirm that this signauture has not already been verified. This\n            // in combination with the signature length check guarantees that\n            // each archaeologist gets verified and gets verified only once.\n            if (\n                verifiedArchaeologists[sarcoId][\n                    archaeologistSignatures[i].account\n                ]\n            ) {\n                revert LibErrors.SignatureListNotUnique();\n            }\n\n            // Confirm that the archaeologist address in the signature is on the\n            // sarcophagus. The alternative to this is to iterate over each\n            // archaeologist on the sarcophagus and run ecrecover to see if\n            // there is a match. This is much more efficient.\n            if (\n                !LibUtils.archaeologistExistsOnSarc(\n                    sarcoId,\n                    archaeologistSignatures[i].account\n                )\n            ) {\n                revert LibErrors.ArchaeologistNotOnSarcophagus(\n                    archaeologistSignatures[i].account\n                );\n            }\n\n            // Verify that the signature of the sarcophagus identifier came from\n            // the archaeologist. This signature confirms that the archaeologist\n            // approves the parameters of the sarcophagus (fees and resurrection\n            // time) and is ready to work.\n            LibUtils.verifyBytes32Signature(\n                sarcoId,\n                archaeologistSignatures[i].v,\n                archaeologistSignatures[i].r,\n                archaeologistSignatures[i].s,\n                archaeologistSignatures[i].account\n            );\n\n            // Calculates the archaeologist's cursed bond and curses them (locks\n            // up the free bond)\n            LibBonds.curseArchaeologist(\n                sarcoId,\n                archaeologistSignatures[i].account\n            );\n\n            // Add this archaeologist to the mapping of verified archaeologists\n            // so that it can't be checked again.\n            verifiedArchaeologists[sarcoId][\n                archaeologistSignatures[i].account\n            ] = true;\n        }\n\n        // Verify that the signature of the arweave transaction id came from the\n        // arweave archaeologist. This signature confirms that the archaeologist\n        // approves the parameters of the sarcophagus (fees and resurrection\n        // time) and is ready to work. The arweave archaeologist's signature in\n        // particular is also used by the contract to confirm which\n        // archaeologist uploaded the payload to arweave and should be paid the\n        // storage fee.\n        LibUtils.verifyBytesSignature(\n            bytes(arweaveTxId),\n            arweaveArchaeologistSignature.v,\n            arweaveArchaeologistSignature.r,\n            arweaveArchaeologistSignature.s,\n            s.sarcophagi[sarcoId].arweaveArchaeologist\n        );\n\n        // Calculates the arweave archaeologist's cursed bond and curses\n        // them (locks up the free bond)\n        LibBonds.curseArchaeologist(\n            sarcoId,\n            s.sarcophagi[sarcoId].arweaveArchaeologist\n        );\n\n        // Store the arweave transaction id to the sarcophagus. The arweaveTxId\n        // being populated indirectly designates the sarcophagus as finalized.\n        s.sarcophagi[sarcoId].arweaveTxIds.push(arweaveTxId);\n\n        // Transfer the storage fee to the arweave archaeologist's reward pool\n        // after setting the arweave transaction id.\n        // TODO: Discuss, confirm if this is okay:\n        // Is there value in directly transferring the storage fee to the\n        // archaeologist on finalise?\n        LibRewards.increaseRewardPool(\n            s.sarcophagi[sarcoId].arweaveArchaeologist,\n            s.sarcophagi[sarcoId].storageFee\n        );\n\n        // Emit an event\n        emit FinalizeSarcophagus(sarcoId, arweaveTxId);\n    }\n\n    /// @notice The embalmer may extend the life of the sarcophagus as long as\n    /// the resurrection time has not passed yet.\n    /// @dev The embalmer sets a new resurrection time sometime in the future.\n    /// @param sarcoId the identifier of the sarcophagus\n    /// @param resurrectionTime the new resurrection time\n    function rewrapSarcophagus(bytes32 sarcoId, uint256 resurrectionTime)\n        external\n    {\n        // Confirm that the sarcophagus exists\n        if (s.sarcophagi[sarcoId].state != LibTypes.SarcophagusState.Exists) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm that the sender is the embalmer\n        if (s.sarcophagi[sarcoId].embalmer != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(\n                msg.sender,\n                s.sarcophagi[sarcoId].embalmer\n            );\n        }\n\n        // Confirm that the sarcophagus is finalized\n        if (!LibUtils.isSarcophagusFinalized(sarcoId)) {\n            revert LibErrors.SarcophagusNotFinalized(sarcoId);\n        }\n\n        // Confirm that the current resurrection time is in the future, and thus rewrappable\n        if (s.sarcophagi[sarcoId].resurrectionTime <= block.timestamp) {\n            revert LibErrors.SarcophagusIsUnwrappable();\n        }\n\n        // Confirm that the new resurrection time is in the future\n        if (resurrectionTime <= block.timestamp) {\n            revert LibErrors.NewResurrectionTimeInPast(resurrectionTime);\n        }\n\n        // Confirm that the new resurrection time is not more than\n        // `maxResurrectionInterval` seconds into the future\n        if (\n            resurrectionTime - block.timestamp >\n            s.sarcophagi[sarcoId].maxResurrectionInterval\n        ) {\n            revert LibErrors.NewResurrectionTimeTooLarge(\n                s.sarcophagi[sarcoId].resurrectionTime\n            );\n        }\n\n        // For each archaeologist on the sarcophagus, transfer their digging fee allocations to them\n        address[] memory bondedArchaeologists = s\n            .sarcophagi[sarcoId]\n            .archaeologists;\n\n        uint256 diggingFeeSum = 0;\n\n        for (uint256 i = 0; i < bondedArchaeologists.length; i++) {\n            // Get the archaeolgist's fee data\n            LibTypes.ArchaeologistStorage memory archaeologistData = LibUtils\n                .getArchaeologist(sarcoId, bondedArchaeologists[i]);\n\n            // Transfer the archaeologist's digging fee allocation to the archaeologist's reward pool\n            LibRewards.increaseRewardPool(\n                bondedArchaeologists[i],\n                archaeologistData.diggingFee\n            );\n\n            // Add the archaeologist's digging fee to the sum\n            diggingFeeSum += archaeologistData.diggingFee;\n        }\n\n        uint256 protocolFee = LibUtils.calculateProtocolFee();\n\n        // Add the protocol fee to the total protocol fees in storage\n        s.totalProtocolFees += protocolFee;\n\n        // Transfer the new digging fees from the embalmer to the sarcophagus contract.\n        // Archaeologists may withdraw their due from their respective reward pools\n        s.sarcoToken.transferFrom(\n            msg.sender,\n            address(this),\n            diggingFeeSum + protocolFee\n        );\n\n        // Emit an event\n        emit RewrapSarcophagus(sarcoId, resurrectionTime);\n    }\n\n    /// @notice Cancels a sarcophagus. An embalmer may cancel a sarcophagus after\n    /// `initializeSarcophagus` but before `finalizeSarcophagus`. The embalmer's\n    /// fees that were locked up will be refunded.\n    /// @param sarcoId the identifier of the sarcophagus\n    function cancelSarcophagus(bytes32 sarcoId) external {\n        // Confirm that the sarcophagus exists\n        if (s.sarcophagi[sarcoId].state != LibTypes.SarcophagusState.Exists) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm that the sender is the embalmer\n        if (s.sarcophagi[sarcoId].embalmer != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(\n                msg.sender,\n                s.sarcophagi[sarcoId].embalmer\n            );\n        }\n\n        // Confirm that the sarcophagus is not already finalized\n        if (LibUtils.isSarcophagusFinalized(sarcoId)) {\n            revert LibErrors.SarcophagusAlreadyFinalized(sarcoId);\n        }\n\n        // Set the sarcophagus state to done\n        s.sarcophagi[sarcoId].state = LibTypes.SarcophagusState.Done;\n\n        address[] memory bondedArchaeologists = s\n            .sarcophagi[sarcoId]\n            .archaeologists;\n\n        // Re-calculate the total fees that the embalmer locked up in initializeSarcophagus\n        uint256 totalFees = LibBonds.calculateTotalFees(\n            sarcoId,\n            bondedArchaeologists\n        );\n\n        // Transfer the total fees back to the embalmer\n        s.sarcoToken.transfer(s.sarcophagi[sarcoId].embalmer, totalFees);\n\n        // Emit an event\n        emit CancelSarcophagus(sarcoId);\n    }\n\n    /// @notice Permanently closes the sarcophagus, giving it no opportunity to\n    /// be resurrected.\n    /// This may only be done after finalizeSarcophagus and before the\n    /// resurrection time has passed.\n    /// @dev Extends the resurrection time into infinity so that that unwrap\n    /// will never be successful.\n    /// @param sarcoId the identifier of the sarcophagus\n    function burySarcophagus(bytes32 sarcoId) external {\n        // Confirm that the sarcophagus exists\n        if (s.sarcophagi[sarcoId].state != LibTypes.SarcophagusState.Exists) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm that the sender is the embalmer\n        if (s.sarcophagi[sarcoId].embalmer != msg.sender) {\n            revert LibErrors.SenderNotEmbalmer(\n                msg.sender,\n                s.sarcophagi[sarcoId].embalmer\n            );\n        }\n\n        // Confirm that the sarcophagus is finalized by checking if there is an\n        // arweaveTxId\n        if (!LibUtils.isSarcophagusFinalized(sarcoId)) {\n            revert LibErrors.SarcophagusNotFinalized(sarcoId);\n        }\n\n        // Confirm that the current resurrection time is in the future\n        if (s.sarcophagi[sarcoId].resurrectionTime <= block.timestamp) {\n            revert LibErrors.ResurrectionTimeInPast(\n                s.sarcophagi[sarcoId].resurrectionTime\n            );\n        }\n\n        // Set resurrection time to infinity\n        s.sarcophagi[sarcoId].resurrectionTime = 2**256 - 1;\n\n        // Set sarcophagus state to done\n        s.sarcophagi[sarcoId].state = LibTypes.SarcophagusState.Done;\n\n        // Total bounty will be added up when we loop through the\n        // archaeologists. This will be sent back to the embalmer.\n        uint256 totalBounty = 0;\n\n        // For each archaeologist on the sarcophagus,\n        // 1. Unlock their cursed bond\n        // 2. Transfer digging fees to the archaeologist.\n        address[] memory bondedArchaeologists = s\n            .sarcophagi[sarcoId]\n            .archaeologists;\n\n        for (uint256 i = 0; i < bondedArchaeologists.length; i++) {\n            // Unlock the archaeologist's cursed bond\n            LibBonds.freeArchaeologist(sarcoId, bondedArchaeologists[i]);\n\n            LibTypes.ArchaeologistStorage memory archaeologistData = LibUtils\n                .getArchaeologist(sarcoId, bondedArchaeologists[i]);\n\n            // Transfer the digging fees to the archaeologist's reward pool\n            LibRewards.increaseRewardPool(\n                bondedArchaeologists[i],\n                archaeologistData.diggingFee\n            );\n\n            // Add the archaeoogist's bounty to totalBounty\n            totalBounty += archaeologistData.bounty;\n        }\n\n        // Transfer the total bounty back to the embalmer (msg.sender)\n        s.sarcoToken.transfer(msg.sender, totalBounty);\n\n        // Emit an event\n        emit BurySarcophagus(sarcoId);\n    }\n}\n"
    },
    "contracts/libraries/LibRewards.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../storage/LibAppStorage.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\n\nlibrary LibRewards {\n    /// @notice Decreases the amount stored in the archaeologistRewards mapping for an\n    /// archaeologist. Reverts if the archaeologist's reward is lower than\n    /// the amount. Called on reward withdraw.\n    /// @param archaeologist The address of the archaeologist whose\n    /// reward is being decreased\n    /// @param amount The amount to decrease the reward by\n    function decreaseRewardPool(address archaeologist, uint256 amount)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        // Revert if the amount is greater than the current reward\n        if (amount > s.archaeologistRewards[archaeologist]) {\n            revert LibErrors.NotEnoughReward(\n                s.archaeologistRewards[archaeologist],\n                amount\n            );\n        }\n\n        // Decrease the rewards amount\n        s.archaeologistRewards[archaeologist] -= amount;\n    }\n\n    /// @notice Increases the amount stored in the archaeologistRewards mapping for an\n    /// archaeologist.\n    /// @param amount The amount to increase the reward by\n    /// @param archaeologist The address of the archaeologist whose\n    /// reward is being increased\n    function increaseRewardPool(address archaeologist, uint256 amount)\n        internal\n    {\n        AppStorage storage s = LibAppStorage.getAppStorage();\n\n        s.archaeologistRewards[archaeologist] += amount;\n    }\n}\n"
    },
    "contracts/facets/ViewStateFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"../libraries/LibTypes.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract ViewStateFacet {\n    AppStorage internal s;\n\n    /// @notice Gets the total protocol fees from the contract.\n    /// @return The total protocol fees\n    function getTotalProtocolFees() external view returns (uint256) {\n        return s.totalProtocolFees;\n    }\n\n    /// @notice Get the protocol fee amount from the contract.\n    /// @return The protocol fee amount\n    function getProtocolFeeAmount() external view returns (uint256) {\n        return s.protocolFee;\n    }\n\n    /// @notice Returns the amount of free bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// free bond is being returned\n    function getFreeBond(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.freeBonds[archaeologist];\n    }\n\n    /// @notice Returns the amount of rewards stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// reward is being returned\n    function getAvailableRewards(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.archaeologistRewards[archaeologist];\n    }\n\n    /// @notice Returns the amount of cursed bond stored in the contract for an\n    /// archaeologist.\n    /// @param archaeologist The address of the archaeologist whose\n    /// cursed bond is being returned\n    function getCursedBond(address archaeologist)\n        external\n        view\n        returns (uint256)\n    {\n        return s.cursedBonds[archaeologist];\n    }\n\n    function getArchaeologistSuccessOnSarcophagus(\n        address archaeologist,\n        bytes32 sarcoId\n    ) external view returns (bool) {\n        return s.archaeologistSuccesses[archaeologist][sarcoId];\n    }\n\n    /// @notice Returns the number of accusations for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose accusations\n    /// are being returned\n    function getArchaeologistAccusals(address archaeologist)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.archaeologistAccusals[archaeologist];\n    }\n\n    /// @notice Returns the number of cleanups for an archaeologist.\n    /// @param archaeologist The address of the archaeologist whose cleanups\n    /// are being returned\n    function getArchaeologistCleanups(address archaeologist)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.archaeologistCleanups[archaeologist];\n    }\n\n    /// @notice Returns a sarcophagus.\n    /// @param sarcoId The identifier of the sarcophagus being returned\n    function getSarcophagus(bytes32 sarcoId)\n        external\n        view\n        returns (LibTypes.Sarcophagus memory)\n    {\n        return s.sarcophagi[sarcoId];\n    }\n\n    /// @notice Given an embalmer's address, returns the identifiers of all\n    /// sarcophagi that the embalmer has created.\n    /// @param embalmer The address of the embalmer whose sarcophagi are being\n    /// returned\n    function getEmbalmersarcophagi(address embalmer)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.embalmerSarcophagi[embalmer];\n    }\n\n    /// @notice Given an archaeologist's address, returns the identifiers of all\n    /// sarcophagi that the archaeologist has participated in.\n    /// @param archaeologist The address of the archaeologist whose sarcophagi\n    /// are being returned\n    function getArchaeologistsarcophagi(address archaeologist)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.archaeologistSarcophagi[archaeologist];\n    }\n\n    /// @notice Given a recipient's address, returns the identifiers of all\n    /// sarcophagi that the recipient has participated in.\n    /// @param recipient The address of the recipient whose sarcophagi are being\n    /// returned\n    function getRecipientsarcophagi(address recipient)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        return s.recipientSarcophagi[recipient];\n    }\n\n    /// @notice Returns the data stored on a sarcophagus for an archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus whose data is being\n    /// returned\n    /// @param archaeologist The address of the archaeologist whose data is\n    /// being returned\n    function getSarcophagusArchaeologist(bytes32 sarcoId, address archaeologist)\n        external\n        view\n        returns (LibTypes.ArchaeologistStorage memory)\n    {\n        return s.sarcophagusArchaeologists[sarcoId][archaeologist];\n    }\n}\n"
    },
    "contracts/facets/ArchaeologistFacet.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../libraries/LibTypes.sol\";\nimport {LibUtils} from \"../libraries/LibUtils.sol\";\nimport {LibErrors} from \"../libraries/LibErrors.sol\";\nimport {LibBonds} from \"../libraries/LibBonds.sol\";\nimport {LibRewards} from \"../libraries/LibRewards.sol\";\nimport {AppStorage} from \"../storage/LibAppStorage.sol\";\n\ncontract ArchaeologistFacet {\n    AppStorage internal s;\n\n    event FinalizeTransfer(\n        bytes32 sarcoId,\n        string arweaveTxId,\n        address oldArchaeologist,\n        address newArchaeologist\n    );\n\n    event UnwrapSarcophagus(bytes32 indexed sarcoId, bytes unencryptedShard);\n\n    event DepositFreeBond(address indexed archaeologist, uint256 depositedBond);\n\n    event WithdrawFreeBond(\n        address indexed archaeologist,\n        uint256 withdrawnBond\n    );\n\n    event WithdrawReward(\n        address indexed archaeologist,\n        uint256 withdrawnReward\n    );\n\n    /// @notice Deposits an archaeologist's free bond to the contract.\n    /// @param amount The amount to deposit\n    function depositFreeBond(uint256 amount) external {\n        // Increase the archaeolgist's free bond in app storage\n        LibBonds.increaseFreeBond(msg.sender, amount);\n\n        // Transfer the amount of sarcoToken from the archaeologist to the contract\n        s.sarcoToken.transferFrom(msg.sender, address(this), amount);\n\n        // Emit an event\n        emit DepositFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws an archaeologist's free bond from the contract.\n    /// @param amount The amount to withdraw\n    function withdrawFreeBond(uint256 amount) external {\n        // Decrease the archaeologist's free bond amount.\n        // Reverts if there is not enough free bond on the contract.\n        LibBonds.decreaseFreeBond(msg.sender, amount);\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amount);\n\n        // Emit an event\n        emit WithdrawFreeBond(msg.sender, amount);\n    }\n\n    /// @notice Withdraws froms an archaeologist's reward pool\n    /// @param amount The amount to withdraw\n    function withdrawReward(uint256 amount) external {\n        LibRewards.decreaseRewardPool(msg.sender, amount);\n\n        // Transfer the amount of sarcoToken to the archaeologist\n        s.sarcoToken.transfer(msg.sender, amount);\n\n        emit WithdrawReward(msg.sender, amount);\n    }\n\n    /// @notice Unwraps the sarcophagus.\n    /// @dev Verifies that the unencrypted shard matches the hashedShard stored\n    /// on chain and pays the archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus to unwrap\n    /// @param unencryptedShard The archaeologist's corresponding unencrypted shard\n    function unwrapSarcophagus(bytes32 sarcoId, bytes memory unencryptedShard)\n        external\n    {\n        // Confirm that the archaeologist has not already unwrapped by checking\n        // if the unencryptedShard is empty\n        LibUtils.archaeologistUnwrappedCheck(sarcoId, msg.sender);\n\n        // Confirm that the sarcophagus exists\n        if (s.sarcophagi[sarcoId].state != LibTypes.SarcophagusState.Exists) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm that the sender is an archaeologist on this sarcophagus\n        if (!LibUtils.archaeologistExistsOnSarc(sarcoId, msg.sender)) {\n            revert LibErrors.ArchaeologistNotOnSarcophagus(msg.sender);\n        }\n\n        // Confirm that the resurrection time has passed and that the\n        // resurrection window has not passed\n        LibUtils.unwrapTime(s.sarcophagi[sarcoId].resurrectionTime);\n\n        // Comfirm that the sarcophagus has been finalized\n        if (!LibUtils.isSarcophagusFinalized(sarcoId)) {\n            revert LibErrors.SarcophagusNotFinalized(sarcoId);\n        }\n\n        // Get the archaeologist's data from storage\n        LibTypes.ArchaeologistStorage memory archaeologistData = LibUtils\n            .getArchaeologist(sarcoId, msg.sender);\n\n        // Confirm that the double hash of the unencrypted shard matches the hashedShard in storage\n        bytes32 doubleHash = keccak256(abi.encode(keccak256(unencryptedShard)));\n        if (doubleHash != archaeologistData.doubleHashedShard) {\n            revert LibErrors.UnencryptedShardHashMismatch(\n                unencryptedShard,\n                archaeologistData.doubleHashedShard\n            );\n        }\n\n        // Store the unencrypted shard in on the archaeologist object in the sarcophagus\n        s\n        .sarcophagusArchaeologists[sarcoId][msg.sender]\n            .unencryptedShard = unencryptedShard;\n\n        // Free the archaeologist's cursed bond\n        LibBonds.freeArchaeologist(sarcoId, msg.sender);\n\n        // Save the successful sarcophagus against the archaeologist\n        s.archaeologistSuccesses[msg.sender][sarcoId] = true;\n\n        // Transfer the bounty and digging fee to the archaeologist's reward pool\n        LibRewards.increaseRewardPool(\n            msg.sender,\n            archaeologistData.bounty + archaeologistData.diggingFee\n        );\n\n        // Emit an event\n        emit UnwrapSarcophagus(sarcoId, unencryptedShard);\n    }\n\n    /// @notice Finalizes a transfer of roles and responsibilities between two\n    /// archaeologists. This is to be called by the new archaeologist.\n    /// @param sarcoId The identifier of the sarcophagus\n    /// @param arweaveTxId The id of the arweave transaction where the new shard\n    /// @param oldArchSignature The signature of the old archaeologist\n    /// was uploaded\n    function finalizeTransfer(\n        bytes32 sarcoId,\n        string memory arweaveTxId,\n        LibTypes.Signature memory oldArchSignature\n    ) external {\n        // Confirm that the sarcophagus exists\n        if (s.sarcophagi[sarcoId].state != LibTypes.SarcophagusState.Exists) {\n            revert LibErrors.SarcophagusDoesNotExist(sarcoId);\n        }\n\n        // Confirm that the sarcophagus has been finalized\n        if (!LibUtils.isSarcophagusFinalized(sarcoId)) {\n            revert LibErrors.SarcophagusNotFinalized(sarcoId);\n        }\n\n        // Confirm that the resurrection time is in the future\n        LibUtils.resurrectionInFuture(s.sarcophagi[sarcoId].resurrectionTime);\n\n        // Get the address that signed the oldArchSignature\n        address oldArchaeologist = LibUtils.recoverAddress(\n            bytes(arweaveTxId),\n            oldArchSignature.v,\n            oldArchSignature.r,\n            oldArchSignature.s\n        );\n\n        // Confirm that the oldArchaeologist is an archaeologist on this\n        // sarcophagus. Failure here means that someone besides an archaeologist\n        // on the sarcophagus signed this message or that the data being signed\n        // was not the provided arweaveTxId.\n        if (!LibUtils.archaeologistExistsOnSarc(sarcoId, oldArchaeologist)) {\n            revert LibErrors.SignerNotArchaeologistOnSarcophagus(\n                sarcoId,\n                oldArchaeologist\n            );\n        }\n\n        // Update the list of archaeologist's on the sarcophagus\n        // For each archaeologist on the sarcophagus, find the old archaeologist\n        // and replace it with the sender's address.\n        for (\n            uint256 i = 0;\n            i < s.sarcophagi[sarcoId].archaeologists.length;\n            i++\n        ) {\n            // Find the archaeologist that matches the old archaeologist's address\n            if (s.sarcophagi[sarcoId].archaeologists[i] == oldArchaeologist) {\n                s.sarcophagi[sarcoId].archaeologists[i] = msg.sender;\n\n                // Once found there is no need to continue\n                break;\n            }\n        }\n\n        // Free the old archaeologist's bond\n        LibBonds.freeArchaeologist(sarcoId, oldArchaeologist);\n\n        LibTypes.ArchaeologistStorage storage newArchData = s\n            .sarcophagusArchaeologists[sarcoId][msg.sender];\n\n        LibTypes.ArchaeologistStorage storage oldArchData = s\n            .sarcophagusArchaeologists[sarcoId][oldArchaeologist];\n\n        // Add the new archaeologist's address to the sarcohpagusArchaeologists mapping\n        newArchData.diggingFee = oldArchData.diggingFee;\n        newArchData.bounty = oldArchData.bounty;\n        newArchData.doubleHashedShard = oldArchData.doubleHashedShard;\n        newArchData.unencryptedShard = \"\";\n\n        // Set the old archaeologist's data in the sarcophagusArchaeologists\n        // mapping to their default values\n        oldArchData.diggingFee = 0;\n        oldArchData.bounty = 0;\n        oldArchData.doubleHashedShard = 0;\n        oldArchData.unencryptedShard = \"\";\n\n        // Add the arweave transaction id to arweaveTxIds on the sarcophagus\n        s.sarcophagi[sarcoId].arweaveTxIds.push(arweaveTxId);\n\n        // Curse the new archaeologist's bond\n        LibBonds.curseArchaeologist(sarcoId, msg.sender);\n\n        // Emit an event\n        emit FinalizeTransfer(\n            sarcoId,\n            arweaveTxId,\n            oldArchaeologist,\n            msg.sender\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}